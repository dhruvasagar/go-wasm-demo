<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üöÄ WebAssembly Performance Benchmarks - JavaScript vs Single-Thread vs Concurrent</title>
    <link rel="stylesheet" href="assets/css/performance.css" />
</head>
<body>
    <!-- Loading Overlay -->
    <div class="loading-overlay" id="loadingOverlay">
        <div class="loader-container">
            <div class="spinner"></div>
            <div class="loading-text" id="loadingText">Preparing Benchmarks...</div>
            <div class="loading-details" id="loadingDetails">Initializing performance tests</div>
            
            <div class="progress-container">
                <div class="progress-label">
                    <span id="progressLabel">Progress</span>
                    <span id="progressPercent">0%</span>
                </div>
                <div class="loading-progress-bar">
                    <div class="loading-progress-fill" id="loadingProgressFill" style="width: 0%;"></div>
                </div>
            </div>
            
            <div class="benchmark-status" id="benchmarkStatus" style="display: none;">
                <div class="current-benchmark" id="currentBenchmark"></div>
                <div class="current-test" id="currentTest"></div>
            </div>
            
            <div class="loading-stats" id="loadingStats" style="display: none;">
                <div class="stat-item">
                    <span class="stat-value" id="completedTests">0</span>
                    <span class="stat-label">Tests Completed</span>
                </div>
                <div class="stat-item">
                    <span class="stat-value" id="totalTests">0</span>
                    <span class="stat-label">Total Tests</span>
                </div>
            </div>
        </div>
    </div>

    <div class="container">
        <div class="header">
            <h1>üöÄ WebAssembly Performance Benchmarks</h1>
            <p>JavaScript vs Single-Thread WASM vs Concurrent WASM</p>
        </div>

        <div class="status loading" id="status">
            Loading WebAssembly module...
        </div>

        <div class="info-box">
            <h4>‚ÑπÔ∏è About This Benchmark</h4>
            <p>This benchmark compares the performance of compute-intensive algorithms across three implementations:</p>
            <ul style="margin-left: 20px; margin-top: 10px;">
                <li><strong>JavaScript</strong>: Native browser implementation</li>
                <li><strong>Single-Thread WASM</strong>: Go compiled to WebAssembly (single-threaded)</li>
                <li><strong>Concurrent WASM</strong>: Go with goroutines and parallelism (multi-threaded)</li>
            </ul>
        </div>

        <div class="controls">
            <h2>‚öôÔ∏è Benchmark Configuration</h2>
            <div class="control-group">
                <div class="control-item">
                    <label for="iterations">Test Iterations:</label>
                    <input type="number" id="iterations" value="5" min="1" max="20">
                </div>
                <div class="control-item">
                    <label for="matrixSize">Matrix Size:</label>
                    <select id="matrixSize">
                        <option value="100">100x100 (Small)</option>
                        <option value="200" selected>200x200 (Medium)</option>
                        <option value="400">400x400 (Large)</option>
                        <option value="800">800x800 (Very Large)</option>
                    </select>
                </div>
                <div class="control-item">
                    <label for="mandelbrotSize">Mandelbrot Size:</label>
                    <select id="mandelbrotSize">
                        <option value="400">400x300 (Small)</option>
                        <option value="800" selected>800x600 (Medium)</option>
                        <option value="1200">1200x900 (Large)</option>
                    </select>
                </div>
                <div class="control-item">
                    <label for="hashIterations">Hash Iterations:</label>
                    <select id="hashIterations">
                        <option value="10000">10,000</option>
                        <option value="50000" selected>50,000</option>
                        <option value="100000">100,000</option>
                        <option value="500000">500,000</option>
                    </select>
                </div>
            </div>
            <button id="runBenchmark" onclick="runAllBenchmarks()">
                üèÅ Run All Benchmarks
            </button>
        </div>

        <div class="progress-bar" id="progressBar" style="display: none;">
            <div class="progress-fill" id="progressFill" style="width: 0%;">0%</div>
        </div>

        <div class="benchmark-grid" id="benchmarkResults">
            <!-- Benchmark results will be inserted here -->
        </div>

        <div class="summary" id="summary" style="display: none;">
            <h2>üìä Benchmark Summary</h2>
            <div class="summary-grid" id="summaryGrid">
                <!-- Summary statistics will be inserted here -->
            </div>
        </div>
    </div>

    <script src="wasm_exec.js"></script>
    <script src="benchmarks_optimized.js"></script>
    <script>
        let wasmReady = false;
        const benchmarkResults = {};
        
        // Loading overlay functions
        function showLoadingOverlay(text = 'Loading...', details = '') {
            const overlay = document.getElementById('loadingOverlay');
            const loadingText = document.getElementById('loadingText');
            const loadingDetails = document.getElementById('loadingDetails');
            
            loadingText.textContent = text;
            loadingDetails.textContent = details;
            
            overlay.classList.remove('hide');
            overlay.classList.add('show');
        }
        
        function hideLoadingOverlay() {
            const overlay = document.getElementById('loadingOverlay');
            overlay.classList.remove('show');
            overlay.classList.add('hide');
            
            setTimeout(() => {
                overlay.style.display = 'none';
                overlay.classList.remove('hide');
            }, 300);
        }
        
        function updateLoadingProgress(completed, total, benchmarkName = '', testName = '') {
            const progressPercent = Math.round((completed / total) * 100);
            const progressFill = document.getElementById('loadingProgressFill');
            const progressPercentSpan = document.getElementById('progressPercent');
            const completedTestsSpan = document.getElementById('completedTests');
            const totalTestsSpan = document.getElementById('totalTests');
            const benchmarkStatus = document.getElementById('benchmarkStatus');
            const currentBenchmark = document.getElementById('currentBenchmark');
            const currentTest = document.getElementById('currentTest');
            const loadingStats = document.getElementById('loadingStats');
            
            // Update progress bar
            progressFill.style.width = progressPercent + '%';
            progressPercentSpan.textContent = progressPercent + '%';
            
            // Update stats
            completedTestsSpan.textContent = completed;
            totalTestsSpan.textContent = total;
            
            // Show stats and benchmark info after first test
            if (completed > 0) {
                loadingStats.style.display = 'grid';
                benchmarkStatus.style.display = 'block';
                
                if (benchmarkName) {
                    currentBenchmark.textContent = benchmarkName;
                }
                if (testName) {
                    currentTest.textContent = `Running: ${testName}`;
                }
            }
            
            // Update loading text based on progress
            const loadingText = document.getElementById('loadingText');
            const loadingDetails = document.getElementById('loadingDetails');
            
            if (progressPercent === 0) {
                loadingText.textContent = 'Starting Benchmarks...';
                loadingDetails.textContent = 'Preparing performance tests';
            } else if (progressPercent < 25) {
                loadingText.textContent = 'Running Initial Tests...';
                loadingDetails.textContent = 'Warming up and measuring baseline performance';
            } else if (progressPercent < 75) {
                loadingText.textContent = 'Processing Benchmarks...';
                loadingDetails.textContent = 'Comparing JavaScript vs WebAssembly performance';
            } else if (progressPercent < 100) {
                loadingText.textContent = 'Finalizing Results...';
                loadingDetails.textContent = 'Completing final tests and calculations';
            } else {
                loadingText.textContent = 'Tests Complete!';
                loadingDetails.textContent = 'Generating performance summary and charts';
            }
        }
        
        // Show initial loading overlay for WebAssembly
        document.addEventListener('DOMContentLoaded', function() {
            showLoadingOverlay('Loading WebAssembly...', 'Downloading and initializing Go WASM module');
            updateLoadingProgress(0, 100);
            
            // Simulate progress for WASM loading
            let wasmProgress = 0;
            const wasmProgressInterval = setInterval(() => {
                wasmProgress += Math.random() * 15;
                if (wasmProgress > 90) wasmProgress = 90;
                updateLoadingProgress(wasmProgress, 100, 'WebAssembly', 'Loading module...');
            }, 200);
            
            // Initialize WebAssembly
            const go = new Go();
            WebAssembly.instantiateStreaming(fetch("main.wasm"), go.importObject).then((result) => {
                clearInterval(wasmProgressInterval);
                updateLoadingProgress(100, 100, 'WebAssembly', 'Module loaded successfully!');
                
                go.run(result.instance);
                wasmReady = true;
                document.getElementById('status').className = 'status ready';
                document.getElementById('status').textContent = '‚úÖ WebAssembly module loaded and ready!';
                document.getElementById('runBenchmark').disabled = false;
                
                // Hide overlay after a brief delay
                setTimeout(() => {
                    hideLoadingOverlay();
                }, 1500);
                
            }).catch((err) => {
                clearInterval(wasmProgressInterval);
                console.error("Failed to load WebAssembly:", err);
                document.getElementById('status').className = 'status error';
                document.getElementById('status').textContent = '‚ùå Failed to load WebAssembly: ' + err.message;
                
                // Update overlay to show error
                document.getElementById('loadingText').textContent = 'Error Loading WebAssembly';
                document.getElementById('loadingDetails').textContent = err.message;
                
                setTimeout(() => {
                    hideLoadingOverlay();
                }, 3000);
            });
        });

        // Benchmark functions
        const benchmarks = [
            {
                name: 'Matrix Multiplication',
                icon: 'üî¢',
                tests: [
                    { name: 'JavaScript', fn: 'matrixMultiplyJS' },
                    { name: 'Single-Thread WASM', fn: 'matrixMultiplyWasm' },
                    { name: 'Concurrent WASM', fn: 'matrixMultiplyConcurrentWasm' }
                ],
                setup: () => {
                    const size = parseInt(document.getElementById('matrixSize').value);
                    const matrixA = new Array(size * size);
                    const matrixB = new Array(size * size);
                    for (let i = 0; i < size * size; i++) {
                        matrixA[i] = Math.random();
                        matrixB[i] = Math.random();
                    }
                    return { matrixA, matrixB, size };
                }
            },
            {
                name: 'Mandelbrot Set',
                icon: 'üåÄ',
                tests: [
                    { name: 'JavaScript', fn: 'mandelbrotJSOptimized' },
                    { name: 'Single-Thread WASM', fn: 'mandelbrotWasm' },
                    { name: 'Concurrent WASM', fn: 'mandelbrotConcurrentWasm' }
                ],
                setup: () => {
                    const sizeStr = document.getElementById('mandelbrotSize').value;
                    const width = parseInt(sizeStr.replace(/\D/g, ''));
                    
                    if (isNaN(width) || width <= 0) {
                        throw new Error('Invalid dimensions');
                    }
                    
                    // Calculate height based on 4:3 aspect ratio
                    const height = Math.floor(width * 0.75);
                    
                    return { 
                        width, 
                        height,
                        xmin: -2.5, 
                        xmax: 1.5, 
                        ymin: -1.5, 
                        ymax: 1.5,
                        maxIter: 150
                    };
                }
            },
            {
                name: 'Cryptographic Hash',
                icon: 'üîê',
                tests: [
                    { name: 'JavaScript', fn: 'hashJS' },
                    { name: 'Single-Thread WASM', fn: 'sha256HashWasm' },
                    { name: 'Concurrent WASM', fn: 'sha256HashConcurrentWasm' }
                ],
                setup: () => {
                    const iterations = parseInt(document.getElementById('hashIterations').value);
                    const data = 'The quick brown fox jumps over the lazy dog. '.repeat(10);
                    return { data, iterations };
                }
            },
            {
                name: 'Ray Tracing',
                icon: 'üé®',
                tests: [
                    { name: 'JavaScript', fn: 'rayTracingJS' },
                    { name: 'Single-Thread WASM', fn: 'rayTracingWasm' },
                    { name: 'Concurrent WASM', fn: 'rayTracingConcurrentWasm' }
                ],
                setup: () => {
                    return { width: 200, height: 150, samples: 10 };
                }
            }
        ];

        async function runAllBenchmarks() {
            if (!wasmReady) {
                alert('WebAssembly module not loaded yet. Please wait.');
                return;
            }

            // Show loading overlay
            showLoadingOverlay('Starting Benchmarks...', 'Preparing performance tests');

            // Clear previous results
            document.getElementById('benchmarkResults').innerHTML = '';
            document.getElementById('summary').style.display = 'none';
            // Clear the benchmarkResults object
            Object.keys(benchmarkResults).forEach(key => delete benchmarkResults[key]);

            // Hide normal progress bar (we'll use overlay progress)
            const progressBar = document.getElementById('progressBar');
            progressBar.style.display = 'none';
            
            const iterations = parseInt(document.getElementById('iterations').value);
            const totalTests = benchmarks.length * 3 * iterations;
            let completedTests = 0;
            
            // Initialize progress
            updateLoadingProgress(0, totalTests);

            function updateProgress(benchmarkName = '', testName = '') {
                completedTests++;
                updateLoadingProgress(completedTests, totalTests, benchmarkName, testName);
            }

            // Run each benchmark
            for (const benchmark of benchmarks) {
                const card = createBenchmarkCard(benchmark.name, benchmark.icon);
                document.getElementById('benchmarkResults').appendChild(card);
                
                const params = benchmark.setup();
                const results = [];

                // Run each test variant
                for (const test of benchmark.tests) {
                    const times = [];
                    const fn = window[test.fn];
                    
                    if (!fn) {
                        console.error(`Function ${test.fn} not found`);
                        results.push({ name: test.name, avg: 0, times: [] });
                        // Still update progress for missing functions
                        for (let i = 0; i < iterations; i++) {
                            updateProgress(benchmark.name, test.name);
                        }
                        continue;
                    }

                    // Warm-up run
                    try {
                        if (benchmark.name === 'Matrix Multiplication') {
                            fn(params.matrixA, params.matrixB, params.size);
                        } else if (benchmark.name === 'Mandelbrot Set') {
                            fn(params.width, params.height, params.xmin, params.xmax, params.ymin, params.ymax, params.maxIter);
                        } else if (benchmark.name === 'Cryptographic Hash') {
                            fn(params.data, params.iterations);
                        } else if (benchmark.name === 'Ray Tracing') {
                            fn(params.width, params.height, params.samples);
                        }
                    } catch (e) {
                        console.error('Warm-up error:', e);
                    }

                    // Timed runs
                    for (let i = 0; i < iterations; i++) {
                        try {
                            const start = performance.now();
                            
                            if (benchmark.name === 'Matrix Multiplication') {
                                fn(params.matrixA, params.matrixB, params.size);
                            } else if (benchmark.name === 'Mandelbrot Set') {
                                fn(params.width, params.height, params.xmin, params.xmax, params.ymin, params.ymax, params.maxIter);
                            } else if (benchmark.name === 'Cryptographic Hash') {
                                fn(params.data, params.iterations);
                            } else if (benchmark.name === 'Ray Tracing') {
                                fn(params.width, params.height, params.samples);
                            }
                            
                            const time = performance.now() - start;
                            times.push(time);
                            updateProgress(benchmark.name, test.name);
                            
                            // Add small delay to make progress visible
                            await new Promise(resolve => setTimeout(resolve, 10));
                        } catch (e) {
                            console.error('Test error:', e);
                            updateProgress(benchmark.name, test.name);
                        }
                    }

                    const avg = times.reduce((a, b) => a + b, 0) / times.length;
                    results.push({ name: test.name, avg, times });
                }

                // Update card with results
                updateBenchmarkCard(card, results);
                benchmarkResults[benchmark.name] = results;
            }

            // Complete progress and show summary
            updateLoadingProgress(totalTests, totalTests, 'Complete!', 'Generating summary...');
            
            // Small delay before showing summary
            await new Promise(resolve => setTimeout(resolve, 500));
            
            showSummary();
            
            // Hide loading overlay
            setTimeout(() => {
                hideLoadingOverlay();
            }, 1000);
        }

        function createBenchmarkCard(name, icon) {
            const card = document.createElement('div');
            card.className = 'benchmark-card';
            card.innerHTML = `
                <h2>${icon} ${name}</h2>
                <div class="benchmark-results">
                    <div class="result-row">
                        <div class="result-label">Implementation</div>
                        <div class="result-time">Avg Time</div>
                        <div class="result-speedup">vs JavaScript</div>
                    </div>
                </div>
            `;
            return card;
        }

        function updateBenchmarkCard(card, results) {
            const resultsDiv = card.querySelector('.benchmark-results');
            const jsTime = results.find(r => r.name === 'JavaScript').avg;

            results.forEach(result => {
                const speedup = jsTime / result.avg;
                const row = document.createElement('div');
                row.className = 'result-row';
                
                let speedupClass = '';
                let speedupText = '';
                
                if (result.name === 'JavaScript') {
                    speedupText = '(baseline)';
                } else {
                    speedupClass = speedup > 1 ? 'speedup-positive' : 'speedup-negative';
                    speedupText = speedup > 1 ? 
                        `${speedup.toFixed(2)}x faster` : 
                        `${(1/speedup).toFixed(2)}x slower`;
                }

                row.innerHTML = `
                    <div class="result-label">${result.name}</div>
                    <div class="result-time">${result.avg.toFixed(1)}ms</div>
                    <div class="result-speedup ${speedupClass}">${speedupText}</div>
                `;
                resultsDiv.appendChild(row);
            });
        }

        function showSummary() {
            const summaryDiv = document.getElementById('summary');
            const summaryGrid = document.getElementById('summaryGrid');
            summaryDiv.style.display = 'block';
            summaryGrid.innerHTML = '';

            // Calculate overall statistics
            const stats = {
                singleThreadSpeedup: [],
                concurrentSpeedup: [],
                concurrentVsSingle: []
            };

            Object.values(benchmarkResults).forEach(results => {
                // Ensure results is an array
                if (!Array.isArray(results)) {
                    console.error('Invalid results format:', results);
                    return;
                }
                
                const jsResult = results.find(r => r.name === 'JavaScript');
                const singleResult = results.find(r => r.name === 'Single-Thread WASM');
                const concurrentResult = results.find(r => r.name === 'Concurrent WASM');
                
                if (jsResult && singleResult && concurrentResult) {
                    const js = jsResult.avg;
                    const single = singleResult.avg;
                    const concurrent = concurrentResult.avg;

                    stats.singleThreadSpeedup.push(js / single);
                    stats.concurrentSpeedup.push(js / concurrent);
                    stats.concurrentVsSingle.push(single / concurrent);
                }
            });

            // Create summary cards
            const summaryData = [
                {
                    title: 'Avg Single-Thread Speedup',
                    value: average(stats.singleThreadSpeedup).toFixed(2) + 'x',
                    color: '#2196F3'
                },
                {
                    title: 'Avg Concurrent Speedup',
                    value: average(stats.concurrentSpeedup).toFixed(2) + 'x',
                    color: '#4CAF50'
                },
                {
                    title: 'Concurrent vs Single-Thread',
                    value: average(stats.concurrentVsSingle).toFixed(2) + 'x',
                    color: '#FF9800'
                },
                {
                    title: 'Best Improvement',
                    value: (stats.concurrentSpeedup.length > 0 ? Math.max(...stats.concurrentSpeedup).toFixed(2) : '0.00') + 'x',
                    color: '#9C27B0'
                }
            ];

            summaryData.forEach(data => {
                const card = document.createElement('div');
                card.className = 'summary-card';
                card.innerHTML = `
                    <h3>${data.title}</h3>
                    <div class="summary-value" style="color: ${data.color}">${data.value}</div>
                `;
                summaryGrid.appendChild(card);
            });
        }

        function average(arr) {
            if (!arr || arr.length === 0) return 0;
            return arr.reduce((a, b) => a + b, 0) / arr.length;
        }

        // JavaScript implementations of benchmark functions
        function matrixMultiplyJS(matrixA, matrixB, size) {
            const result = new Array(size * size);
            for (let i = 0; i < size; i++) {
                for (let j = 0; j < size; j++) {
                    let sum = 0;
                    for (let k = 0; k < size; k++) {
                        sum += matrixA[i * size + k] * matrixB[k * size + j];
                    }
                    result[i * size + j] = sum;
                }
            }
            return result;
        }

        function hashJS(data, iterations) {
            let hash = 0x12345678;
            for (let iter = 0; iter < iterations; iter++) {
                for (let i = 0; i < data.length; i++) {
                    hash = hash * 33 + data.charCodeAt(i);
                    hash = ((hash << 5) | (hash >>> 27)) >>> 0;
                }
            }
            return hash;
        }

        function rayTracingJS(width, height, samples) {
            const result = new Array(width * height * 3);
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const nx = (x / width) * 2.0 - 1.0;
                    const ny = (y / height) * 2.0 - 1.0;
                    
                    let r = 0, g = 0, b = 0;
                    
                    for (let s = 0; s < samples; s++) {
                        // Simplified ray tracing logic
                        const t = Math.sqrt(nx * nx + ny * ny);
                        r += Math.min(1, t);
                        g += Math.min(1, t * 0.7);
                        b += Math.min(1, t * 0.5);
                    }
                    
                    const idx = (y * width + x) * 3;
                    result[idx] = r / samples;
                    result[idx + 1] = g / samples;
                    result[idx + 2] = b / samples;
                }
            }
            
            return result;
        }
    </script>
</body>
</html>
